2022 oct 06
Paramètres des simulations de chauffage RF
Simulations dans le dossier Rivendel/Simulations/20220617

|   cond  | N  | q_x|   f_x   |   f_z   |   ~a_x  | R/L | beta|
|---------|----|----|---------|---------|---------|-----|-----|
|DC05_RF05|0256|0.54|4.081e+05|3.332e+05|5.551e-02|1.228|0.408|
|DC06_RF06|0256|0.56|4.257e+05|3.476e+05|6.041e-02|1.259|0.426|
|DC07_RF07|0256|0.58|4.438e+05|3.623e+05|6.565e-02|1.260|0.444|
|DC08_RF08|0256|0.60|4.622e+05|3.774e+05|7.122e-02|1.292|0.462|
|DC09_RF09|0256|0.62|4.812e+05|3.929e+05|7.718e-02|1.325|0.481|
|DC10_RF10|0256|0.64|5.007e+05|4.088e+05|8.356e-02|1.377|0.501|
|DC11_RF11|0256|0.66|5.208e+05|4.252e+05|9.040e-02|1.420|0.521|
|DC12_RF12|0256|0.68|5.415e+05|4.421e+05|9.775e-02|1.451|0.542|
|DC13_RF13|0256|0.70|5.631e+05|4.597e+05|1.057e-01|1.497|0.563|
|DC03_RF03|0512|0.00|0.000e+00|0.000e+00|0.000e+00|1.050|0.000|
|DC04_RF04|0512|0.00|0.000e+00|0.000e+00|0.000e+00|1.050|0.000|
|DC05_RF05|0512|0.54|4.081e+05|3.332e+05|5.551e-02|1.185|0.408|
|DC06_RF06|0512|0.56|4.257e+05|3.476e+05|6.041e-02|1.244|0.426|
|DC07_RF07|0512|0.58|4.438e+05|3.623e+05|6.565e-02|1.257|0.444|
|DC08_RF08|0512|0.60|4.622e+05|3.774e+05|7.122e-02|1.287|0.462|
|DC09_RF09|0512|0.62|4.812e+05|3.929e+05|7.718e-02|1.316|0.481|
|DC10_RF10|0512|0.64|5.007e+05|4.088e+05|8.356e-02|1.366|0.501|
|DC11_RF11|0512|0.66|5.208e+05|4.252e+05|9.040e-02|1.397|0.521|
|DC12_RF12|0512|0.68|5.415e+05|4.421e+05|9.775e-02|1.433|0.542|
|DC13_RF13|0512|0.70|5.631e+05|4.597e+05|1.057e-01|1.492|0.563|
|DC05_RF05|1024|0.54|4.081e+05|3.332e+05|5.551e-02|1.205|0.408|
|DC06_RF06|1024|0.56|4.257e+05|3.476e+05|6.041e-02|1.236|0.426|
|DC07_RF07|1024|0.58|4.438e+05|3.623e+05|6.565e-02|1.246|0.444|
|DC08_RF08|1024|0.60|4.622e+05|3.774e+05|7.122e-02|1.282|0.462|
|DC09_RF09|1024|0.62|4.812e+05|3.929e+05|7.718e-02|1.305|0.481|
|DC10_RF10|1024|0.64|5.007e+05|4.088e+05|8.356e-02|1.340|0.501|
|DC11_RF11|1024|0.66|5.208e+05|4.252e+05|9.040e-02|1.393|0.521|
|DC12_RF12|1024|0.68|5.415e+05|4.421e+05|9.775e-02|1.424|0.542|
|DC13_RF13|1024|0.70|5.631e+05|4.597e+05|1.057e-01|1.468|0.563|
|DC19_RF19|1024|0.63|4.909e+05|4.000e+05|8.000e-02|1.332|0.491|
|DC20_RF20|1024|0.61|4.717e+05|3.847e+05|7.400e-02|1.303|0.472|
|DC21_RF21|1024|0.61|4.736e+05|3.867e+05|7.475e-02|1.312|0.474|
|DC22_RF22|1024|0.61|4.755e+05|3.882e+05|7.535e-02|1.310|0.475|
|DC23_RF23|1024|0.62|4.774e+05|3.897e+05|7.595e-02|1.310|0.477|
|DC24_RF24|1024|0.62|4.793e+05|3.913e+05|7.655e-02|1.308|0.479|
|DC25_RF25|1024|0.62|4.831e+05|3.945e+05|7.780e-02|1.313|0.483|
|DC26_RF26|1024|0.62|4.850e+05|3.960e+05|7.840e-02|1.327|0.485|
|DC27_RF27|1024|0.66|5.208e+05|3.976e+05|7.905e-02|1.320|0.521|
|DC28_RF28|1024|0.68|5.415e+05|3.992e+05|7.970e-02|1.329|0.542|
|DC29_RF29|1024|0.61|4.726e+05|3.859e+05|7.445e-02|1.291|0.473|
|DC30_RF30|1024|0.61|4.745e+05|3.874e+05|7.505e-02|1.299|0.475|
|DC31_RF31|1024|0.61|4.764e+05|3.890e+05|7.565e-02|1.311|0.476|
|DC32_RF32|1024|0.62|4.783e+05|3.905e+05|7.625e-02|1.310|0.478|
|DC33_RF33|1024|0.62|4.802e+05|3.920e+05|7.685e-02|1.311|0.480|
|DC34_RF34|1024|0.62|4.822e+05|3.937e+05|7.750e-02|1.317|0.482|
|DC35_RF35|1024|0.62|4.841e+05|3.952e+05|7.810e-02|1.315|0.484|
|DC36_RF36|1024|0.62|4.860e+05|3.969e+05|7.875e-02|1.320|0.486|
|DC37_RF37|1024|0.63|4.880e+05|3.984e+05|7.935e-02|1.328|0.488|
|DC38_RF38|1024|0.63|4.899e+05|4.000e+05|8.000e-02|1.251|0.490|

L'objectif était de simuler des nuages avec R/L = 1. Or R/L est plutôt autour de 1.3.
Une erreur dans le calcul des Udc et Urf est à l'origine de ce problème.
Dans le calcul je choisi des q, calcule un beta, avec a = 0, ce qui ne prend pas en compte
le caractère déconfinant du potentiel axial. Pour corriger le problème, je propose de mettre
le calcul de beta et a dans une boucle, de réinjecter a dans le beta. En 10 itérations le
a converge.

Le mauvais code Python utilisé pour le calcul des Udc et Urf afin d'obtenir R/L = 1 (faux)

# Give q
# compute URF, beta, UDC for spherical cloud
# compute secular frequencies

# Udc = 10.93 # 2.8628*4   9.014464
q = np.linspace(0.54,0.70,9)
# np.linspace(0.61,0.63,21) # np.linspace(0.54,0.70,9) # 
# array([0.611, 0.613, 0.615, 0.617, 0.619, 0.621, 0.623, 0.625, 0.627, 0.629])
print('q',q)
Urf = q*(m_Ca*r0**2*Omega**2)/(4*C_e)
print('Urf =',Urf)
beta_guess = 0.423
a = 0
for k in range(750):
    beta_guess = beta_continue_alamano(a,q,beta_guess)
    beta_guess = sqrt(beta_guess)
#     print(beta_guess)
print('non adiab',beta_guess)
print('adiab    ',sqrt(a+q**2/2))
# Udc_for_alpha1 = 1/6*(beta_guess*Omega/(2*pi*100000))**2
# beta_guess = sqrt(a+q**2/2)
Udc_for_alpha1 = m_Ca*d0**2/(3*kappa_simion*C_e)*(0.5*beta_guess*Omega)**2
print('Udc_for_alpha1 =',Udc_for_alpha1)
# Udc = array([10.027, 12, 13.848,15.85, 17.669,19.7, 21.49]) # Udc_for_alpha1
# omega_z_2 = 2*C_e*(mkappa)*Udc/m_Ca/d0**2
# omega_x_2 = 2*(C_e*Urf/m_Ca/Omega/r0**2)**2
omega_z_2 = ( 2*pi*100e3 )**2 * Udc_for_alpha1
# omega_z_2 = 2*kappa_simion*C_e/(m_Ca*d0**2) * Udc
omega_x_2 = ( beta_guess*Omega/2 )**2
omega_r_2 = omega_x_2 - 0.5*omega_z_2

qx = 4*C_e*Urf/(m_Ca*r0**2*Omega**2)
ax = 8*C_e*0/(m_Ca*r0**2*Omega**2)
az = 2*omega_z_2/Omega**2

print('alpha =',omega_z_2/omega_r_2)
print('qx =',qx)
print('ax =',ax)
print('az =',az)
print('f_z =',sqrt(omega_z_2)/2/pi)
print('f_x =',sqrt(omega_x_2)/2/pi)
print('f_r =',sqrt(omega_r_2)/2/pi)
